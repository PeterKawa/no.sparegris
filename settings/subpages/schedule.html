<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link href="../style.css" rel="stylesheet" type="text/css">
    <link href="../trashcan.css" rel="stylesheet" type="text/css">
    <style>
.scheduleLegend {
  display: table;
  padding: 0px;
  border-spacing: 0px;
  border: solid 0px;
}

.scheduleLegendBox {
  width: 50px;
  vertical-align: top;
  padding: 0px;
  border: solid 0px;
  border-right: solid 1px;
}

.scheduleLegendText {
  height: 16px;
  font-weight: bold;
  font-family: monospace;
  font-size: 0.8rem;
  text-transform: uppercase;
  text-align: right;
  position: relative;
  padding-right: 10px;
  overflow: hidden;
}

.scheduleLegendText:after{
  content:"   ";
  height: 2px;
  width: 5px;
  background: black;
  display: block;
  position: absolute;
  top: 50%;
  right: 0;
}

.schedulePlan {
  display: table-cell;
  width: 130px;
  vertical-align: top;
  padding: 0rem;
  border-right: solid 0px;
  touch-action: none;
}

.scheduleItem {
  display: block;
  overflow: auto;
  border-radius: 8px;
  width: 100%;
  padding: 0px;
  padding-top: 5px;
  border: solid 0px;
  text-align:center;
  font-size: 0.8rem;
  box-sizing: border-box;
}

.schedCol0 {
  /* UNCONDITIONAL_OFF */
  border: solid gray 1px;
  background-image: linear-gradient(lightgray, gray);
}

.schedCol1 {
  /* UNCONDITIONAL_ON*/
  border: solid red 1px;
  background-image: linear-gradient(rgb(255, 255, 150), orange);
}

.schedCol2 {
  /* CONTROLLED_OFF */
  border: solid black 1px;
  background-image: linear-gradient(rgb(150, 255, 150), green);
}

.schedCol3 {
  /* CONTROLLED_ON */
  border: solid green 1px;
  background-image: linear-gradient(green, rgb(150, 255, 150));
}

.schedCol4 {
  /* IGNORE */
  border: solid black 1px;
  background-image: linear-gradient(gray, lightgray);
}

.scheduleSelect {
  opacity: 0.6;
}

.scheduleSpacer {
  display: block;
  position: absolute;
  opacity: 60%;
  left: 20%;
  right: 20%;
  padding: 0px;
  border: 0px;
  height: 20px;
  background-image: linear-gradient(rgba(100,100,100,0), gray 35%, black 35% 45%, gray 45% 55%, black 55% 65%, gray 65%, rgba(100,100,100,0));
}

.scheduleSpacer:hover {
  cursor: ns-resize;
}
    </style>
  </head>
  <body>
    <h3>Time Schedule Preview</h3>
    <p>This is a preview / testing ground of upcoming functionality. The Layout may differ in the final version. Absolutely nothing will be affected if you play around here.</p>
    <p>The intent is that you can assign a schedule per device under each mode instead of an operation.</p>
    <p>Price behavior is likely to be part of the schedule.</p>
    <p>If you have any feedback before this is finalized please put it in the forum.</p>
    <fieldset>
      <legend data-i18n="settings.schedule.schedules">Schedules</legend>
      <select id="allSchedules" onchange="selectSchedule(this.value);">
      </select><br>
      <label for="timerOpName" data-i18n="settings.schedule.name">Name</label>:
      <input id="timerOpName" type="text" onchange="schedules[scheduleSelected].name = this.value || 'Noname';refreshSchedules();displaySaveHint()"><br>
      <input type="button" value="New" onclick="addSchedule();">
      <input type="button" value="Remove" onclick="removeSchedule();"><br>
    </fieldset>
    <table class="scheduleLegend">
      <tr>
        <td class="scheduleLegendBox"><div class="scheduleLegendText">0:00</div>
          <div class="scheduleLegendText">1:00</div>
          <div class="scheduleLegendText">2:00</div>
          <div class="scheduleLegendText">3:00</div>
          <div class="scheduleLegendText">4:00</div>
          <div class="scheduleLegendText">5:00</div>
          <div class="scheduleLegendText">6:00</div>
          <div class="scheduleLegendText">7:00</div>
          <div class="scheduleLegendText">8:00</div>
          <div class="scheduleLegendText">9:00</div>
          <div class="scheduleLegendText">10:00</div>
          <div class="scheduleLegendText">11:00</div>
          <div class="scheduleLegendText">12:00</div>
          <div class="scheduleLegendText">13:00</div>
          <div class="scheduleLegendText">14:00</div>
          <div class="scheduleLegendText">15:00</div>
          <div class="scheduleLegendText">16:00</div>
          <div class="scheduleLegendText">17:00</div>
          <div class="scheduleLegendText">18:00</div>
          <div class="scheduleLegendText">19:00</div>
          <div class="scheduleLegendText">20:00</div>
          <div class="scheduleLegendText">21:00</div>
          <div class="scheduleLegendText">22:00</div>
          <div class="scheduleLegendText">23:00</div>
          <div class="scheduleLegendText">24:00</div></td>
        <td width="10"></td>
        <td id="scheduleContainer" class="schedulePlan" onpointerup="dragStop(event)" onpointermove="moving(event)"></td>
        <td width="10"></td>
        <td rowspan="2" valign="top">
          <fieldset id='scTime'>
            <legend data-i18n="settings.schedule.schedule">Timeslot</legend>
            <label for="timerOpOnOff" data-i18n="settings.schedule.onoff">OnOff operation</label>:
            <div class="hintButton" onclick="parent.toggle(this,'onOffOperationHint');return false;">i</div><br>
            <div class="imgButtonText" id="timerOpOnOff" onclick="changeScheduleOp(this);">N/A</div><br>
            <p id="onOffOperationHint" class="hint" data-i18n="settings.schedule.onOffOperationHint">schedule.onOffOperationHint</p>
            <label for="timerOpTemp" data-i18n="settings.schedule.temp">Temperature</label>:
            <div class="hintButton" onclick="parent.toggle(this,'tempOpHint');return false;">i</div><br>
            <select id="timerOpTemp" onchange="changeTempOp(this.value);displaySaveHint();">
                <option value="0" data-i18n="settings.schedule.notemp">No temp control</option>
                <option value="1" data-i18n="settings.schedule.statictemp">Static temperature</option>
                <option value="2" data-i18n="settings.schedule.pricetemp">Price controlled</option>
            </select><br>
            <p id="tempOpHint" class="hint" data-i18n="settings.schedule.tempOpHint">schedule.tempOpHint</p>
            <label for="timerACMode" data-i18n="settings.ACMode.header">AC Mode</label>:
            <div class="hintButton" onclick="parent.toggle(this,'ACModeHint');return false;">i</div><br>
            <select id="timerACMode" onchange="changeACMode(this.value);displaySaveHint();">
              <option value="6" data-i18n="settings.ACMode.fan">Piggy</option>
              <option value="0" data-i18n="settings.ACMode.fromAC">Unchanged</option>
              <option value="1" data-i18n="settings.ACMode.auto">Auto</option>
              <option value="2" data-i18n="settings.ACMode.heat">Heating</option>
              <option value="3" data-i18n="settings.ACMode.cool">Cooling</option>
              <option value="4" data-i18n="settings.ACMode.dry">Dry</option>
              <option value="5" data-i18n="settings.ACMode.fan">Fan</option>
            </select><br>
            <p id="ACModeHint" class="hint" data-i18n="settings.schedule.ACModeHint">schedule.ACModeHint</p>
            <div id="thermoTab">
              <canvas id="myThermostat" width="180" height="180" style="border:0px solid #d3d3d3;" onpointermove="draggingThermo(this, event);" onpointerdown="startDragThermo(this, event);" onpointerup="stopDragThermo(this, event);" onpointerleave="stopDragThermo(this, event);">
                Your browser does not support the HTML5 canvas tag.
              </canvas>
              <div class="hintButton" style="position: relative; top: -150px; left: -30px;" onclick="parent.toggle(this,'myThermoHint');return false;">i</div>
              <p id="thermoGuide"></p>
              <p id="myThermoHint" class="hint" data-i18n="settings.schedule.myThermoHint">schedule.myThermoHint</p>
            </div>
          </fieldset>
          <div hidden>
            <div id="scTemp">
              <label for="timerBaseTempHeat" data-i18n="settings.schedule.basetemp">Base temperature (heating)</label>:<br>
              <input id="timerBaseTempHeat" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeBaseTemp(this.value);displaySaveHint()">°C<br>
              <div id="coolBase">
                <label for="timerBaseTempCool" data-i18n="settings.schedule.basetemp">Base temperature (cooling)</label>:<br>
                <input id="timerBaseTempCool" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeBaseTemp(this.value);displaySaveHint()">°C<br>
              </div>
            </div>
            <fieldset id='scPP'>
            <legend data-i18n="settings.menu.devices.prices">Price adjust</legend>
            <label for="tempDirtCheap" data-i18n="settings.pricetab.dirtcheap">Dirt Cheap</label>:<br>
            <input id="tempDirtCheap" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeDeltaTemp(0, this.value);displaySaveHint()">°C<br>
            <label for="tempCheap" data-i18n="settings.pricetab.cheap">Cheap</label>:<br>
            <input id="tempCheap" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeDeltaTemp(1, this.value);displaySaveHint()">°C<br>
            <label for="tempExpensive" data-i18n="settings.pricetab.expensive">Expensive</label>:<br>
            <input id="tempExpensive" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeDeltaTemp(3, this.value);displaySaveHint()">°C<br>
            <label for="tempExtreme" data-i18n="settings.pricetab.extreme">Extreme</label>:<br>
            <input id="tempExtreme" class="inputElem" type="number" min="-30" max="90" step="0.5" onchange="changeDeltaTemp(4, this.value);displaySaveHint()">°C<br>
          </fieldset>
          </div>
        </td>
      </tr>
      <tr><td colspan="2"></td><td style="vertical-align:top;"><input style="width:100%" type="button" value="+" onclick="addTimer();"></td></tr>
    </table>

    <script type="text/javascript">
      // TODO: REMOVE THE PARENT VARIABLE
      const parent = {
        DEVICE_OP: {UNCONDITIONAL_OFF: 0, UNCONDITIONAL_ON: 1, CONTROLLED_OFF: 2, CONTROLLED_ON: 3, IGNORE: 4},
        TEMP_OP: {NONE: 0, STATIC: 1, PRICE: 2},
        ACMODE: {UNCHANGED: 0, AUTO: 1, HEAT: 2, COOL: 3, DRY: 4, FAN: 5, PIGGY: 6},
        displaySaveHint: (param => {console.log('TODO REMOVEME');}),
        toggle: (source, id, type = 'block') => {var e = document.getElementById(id);var visible = (e.style.display != "") && (e.style.display != "none");if (visible) { e.style.display = 'none'; if (source) source.style.cursor = "zoom-in";} else { e.style.display = type; if (source) source.style.cursor = "zoom-out"; } return false; },
        KEEP: -1,
        turnOffText: 'Always Off',
        turnOnText: 'Always On',
        preferredOnText: 'Preferred On', // Nonexisting
        emergencyOffText: 'Controlled Off',
        ignoreText: 'Ignore',
      }
      // --- End of TODO ---
      const startTemp = 5;
      const endTemp = 45;
      let temps = [5, 15, 20, 21, 22, 23, 24, 25, 26, 27, 30, 45];

      const tempsID = {
      HEAT_OFF:       0,
      HEAT_EXPENSIVE: 1,
      HEAT_HIGH:      2,
      HEAT_NORMAL:    3,
      HEAT_CHEAP:     4,
      HEAT_DIRTCHEAP: 5,
      COOL_DIRTCHEAP: 6,
      COOL_CHEAP:     7,
      COOL_NORMAL:    8,
      COOL_HIGH:      9,
      COOL_EXPENSIVE: 10,
      COOL_OFF:       11,
    }
    const tempName = {
      0: 'thermostat.HEAT_OFF',
      1: 'thermostat.HEAT_EXPENSIVE',
      2: 'thermostat.HEAT_HIGH',
      3: 'thermostat.HEAT_NORMAL',
      4: 'thermostat.HEAT_CHEAP',
      5: 'thermostat.HEAT_DIRTCHEAP',
      6: 'thermostat.COOL_DIRTCHEAP',
      7: 'thermostat.COOL_CHEAP',
      8: 'thermostat.COOL_NORMAL',
      9: 'thermostat.COOL_HIGH',
      10: 'thermostat.COOL_EXPENSIVE',
      11: 'thermostat.COOL_OFF',
    }
    const TEMPOP = {
      NONE: 0,
      STATIC: 1,
      PRICE: 2
    }
    const totalHeight = 24*16;
    const pixelsPerMinute = (totalHeight) / (24 * 60);
    let minuteSnap = 30;
    let scheduleMin = 1;
    let scheduleMax = 8;
    let scheduleSelected = 0;
    let schedules = [{
        name: "Weekday - Living Room",
        deltaTemp: 1,
        items: [{
          start: 0,
          operation: parent.DEVICE_OP.CONTROLLED_ON,
          tempOp: parent.TEMP_OP.PRICE,
          temp: [5, 12, 13, 15, 17, 18, 27, 28, 29, 30, 31, 40],
          ACMode: 0
        },
        {
          start: 6*60,
          operation: parent.DEVICE_OP.CONTROLLED_ON,
          tempOp: parent.TEMP_OP.PRICE,
          temp: [5, 17, 18, 20, 22, 23, 25, 26, 27, 28, 29, 40],
          ACMode: 0
        },
        {
          start: 15*60,
          operation: parent.DEVICE_OP.CONTROLLED_ON,
          tempOp: parent.TEMP_OP.PRICE,
          temp: [5, 21, 22, 24, 26, 27, 27, 28, 29, 30, 31, 40],
          ACMode: 0
        },
        {
          start: 22*60,
          operation: parent.DEVICE_OP.CONTROLLED_ON,
          tempOp: parent.TEMP_OP.PRICE,
          temp: [5, 12, 13, 15, 17, 18, 27, 28, 29, 30, 31, 40],
          ACMode: 0
        }]
    }];
    let timerSelected = undefined;
    var dragging = false;
    let aboveIdx;
    let belowIdx;
    let prevPosY;
    let aboveItem;
    let belowItem;

    function changeTempOp(newTempOp) {
      if (!(scheduleSelected in schedules) || (timerSelected == undefined)) {
        return;
      }
      const curSchedule = schedules[scheduleSelected];
      const items = curSchedule.items;
      items[timerSelected].tempOp = +newTempOp;
      // Refresh
      refreshTempOp();
      refreshTimeTable();
      refreshThermostat();
    }

    function changeACMode(newMode) {
      if (timerSelected === undefined) return;
      schedules[scheduleSelected].items[timerSelected].ACMode = +newMode;
      if (+newMode === parent.ACMODE.DRY || +newMode === parent.ACMODE.FAN) {
        document.getElementById('timerOpTemp').value = TEMPOP.NONE;
        //newMode === parent.ACMODE.UNCHANGED;
      }
      if (+newMode === parent.ACMODE.AUTO) {
        document.getElementById('timerOpTemp').value = TEMPOP.STATIC;
        //newMode === parent.ACMODE.UNCHANGED;
      }
      showHeat = ((+newMode === parent.ACMODE.PIGGY) || (+newMode === parent.ACMODE.HEAT) || (+newMode === parent.ACMODE.UNCHANGED)  || (+newMode === parent.ACMODE.AUTO))
      showCool = ((+newMode === parent.ACMODE.PIGGY) || (+newMode === parent.ACMODE.COOL) || (+newMode === parent.ACMODE.UNCHANGED))
      document.getElementById('coolBase').style.display = showCool ? 'block' : 'none';
      refreshTempOp();
      refreshTimeTable();
      refreshThermostat();
    }

    function changeBaseTemp(newTemp) {
      schedules[scheduleSelected].items[timerSelected].temp = +newTemp;
      refreshTimeTable();
    }

    function refreshTempOp() {
      const tempElement = document.getElementById('scTemp');
      const ppElements = document.getElementById('scPP');
      const tempOp = +document.getElementById('timerOpTemp').value;
      const timerACMode = +document.getElementById('timerACMode').value;
      const thermoTab = document.getElementById('thermoTab');
      if (tempOp === parent.TEMP_OP.NONE
        || timerACMode === parent.ACMODE.DRY
        || timerACMode === parent.ACMODE.FAN) {
        tempElement.style.display = "none";
        ppElements.style.display = "none";
        thermoTab.style.display = "none";
      } else if (tempOp === parent.TEMP_OP.STATIC
        || timerACMode === parent.ACMODE.AUTO) {
        tempElement.style.display = "block";
        ppElements.style.display = "none";
        thermoTab.style.display = "block";
      } else if (tempOp === parent.TEMP_OP.PRICE) {
        tempElement.style.display = "block";
        ppElements.style.display = "block";
        thermoTab.style.display = "block";
      }
      // Change AC options
      document.querySelectorAll("#timerACMode option").forEach(opt => {
        if (((tempOp === TEMPOP.NONE)
          && ((+(opt.value) !== parent.ACMODE.FAN)
            && (+(opt.value) !== parent.ACMODE.DRY)
            && (+(opt.value) !== parent.ACMODE.UNCHANGED)))
          || ((tempOp === TEMPOP.PRICE)
            && (+opt.value === parent.ACMODE.AUTO
              || +opt.value === parent.ACMODE.DRY
              || +opt.value === parent.ACMODE.FAN))
          || ((tempOp === TEMPOP.STATIC)
            && (+opt.value === parent.ACMODE.DRY
             || +opt.value === parent.ACMODE.FAN))) {
          opt.disabled = true;
        } else {
          opt.disabled = false;
        }
      });
    }

    function selectSchedule(value) {
      scheduleSelected = value;
      timerSelected = undefined;
      const nameElement = document.getElementById('timerOpName');
      const ppDirtElement = document.getElementById('tempDirtCheap');
      const ppCheapElement = document.getElementById('tempCheap');
      const ppExpensiveElement = document.getElementById('tempExpensive');
      const ppExtremeElement = document.getElementById('tempExtreme');
      if (value in schedules) {
        nameElement.disabled = false;
        nameElement.value = schedules[value].name;
      } else {
        nameElement.disabled = true;
        nameElement.value = '';
      }
      selectTimer(undefined);
      refreshTimeTable();
    }

    function addSchedule() {
      let newSchedule = {
        name: 'New Schedule',
        deltaTemp: 1,
        items: [{
          start: 0,
          operation: parent.DEVICE_OP.CONTROLLED_ON,
          tempOp: parent.TEMP_OP.PRICE,
          temp: [5, 20, 21, 23, 25, 26, 27, 28, 29, 30, 31, 45],
          ACMode: 0
        }]
      };
      schedules.push(newSchedule);
      selectSchedule(schedules.length - 1);
      refreshSchedules();
    }

    function removeSchedule() {
      if ((scheduleSelected == '')
        || (+scheduleSelected > (schedules.length-1))
        || (schedules.length === 1)) {
        return;
      }
      if (timerSelected !== undefined) selectTimer(timerSelected); // Deselect timer if selected
      schedules.splice(scheduleSelected,1);
      selectSchedule('');
      refreshSchedules();
      document.getElementById('allSchedules').value='';
    }

    function refreshSchedules(change) {
      let allSchedulesElement = document.getElementById('allSchedules');
      let newList = '';
      for (let i = 0; i < schedules.length; i++) {
        const selectText = (i === scheduleSelected) ? ' selected' : '';
        newList += `<option value="${i}"${selectText}>${schedules[i].name}</option>"`;
      }
      allSchedulesElement.innerHTML = newList;
      refreshTimeTable();
    }

    function timerHeight(item) {
      const items = schedules[scheduleSelected].items;
      const abovePos = items[item].start;
      const belowPos = ((item + 1) >= items.length) ? (24 * 60) : items[item + 1].start;
      const height = (belowPos - abovePos) * pixelsPerMinute;
      return height;
    }

    function addTimer() {
      if (!(scheduleSelected in schedules)) {
        return;
      }
      const curSchedule = schedules[scheduleSelected];
      const items = curSchedule.items;
      const numTimers = items.length;
      if (numTimers < scheduleMax) {
        items[numTimers] = {
          ...items[numTimers-1],
          start: (items[numTimers - 1].start + 24 * 60) / 2
        }
        let lastStart = 24 * 60;
        for (let i = numTimers; i > 0; i--) {
          if (lastStart - items[i].start < 60) {
            items[i].start = lastStart - 60;
          }
          lastStart = items[i].start;
        }
      }
      displaySaveHint();
      refreshTimeTable();
    }

    function removeTimer(idx) {
      if (!(scheduleSelected in schedules)) {
        return;
      }
      if (timerSelected !== undefined) selectTimer(timerSelected); // Deselect timer if selected
      const items = schedules[scheduleSelected].items;
      const numTimers = items.length;
      if (numTimers > scheduleMin) {
        items.splice(idx, 1);
        items[0].start = 0;
      }
      displaySaveHint();
      refreshTimeTable();
    }

    function getTimeBlockText(idx) {
      const curSchedule = schedules[scheduleSelected]
      const items = curSchedule.items;
      const startTime = items[idx].start;
      const endTime = ((idx + 1) >= items.length) ? (24 * 60) : items[idx+1].start;
      const hourStart = String(Math.floor(startTime / 60)).padStart(2, '0');
      const minStart = String(startTime % 60).padStart(2, '0');
      const hourEnd = String(Math.floor(endTime / 60)).padStart(2, '0');
      const minEnd = String(endTime % 60).padStart(2, '0');
      const tempOp = items[idx].tempOp;
      const trashCan = (items.length === 1) ? '' :
        `<div id="scTrashCan" class="icon-trash" style="float:right; font-size:1rem" onClick="removeTimer(${idx});event.stopPropagation();displaySaveHint();">`
        + '  <div class="trash-lid" style="background-color: #e44"></div>'
        + '  <div class="trash-container" style="background-color: #e44"></div>'
        + '  <div class="trash-line-1"></div>'
        + '  <div class="trash-line-2"></div>'
        + '  <div class="trash-line-3"></div>'
        + '</div>';
      const tempMin = items[idx].temp[tempsID.HEAT_EXPENSIVE];
      const tempMax = items[idx].temp[tempsID.COOL_EXPENSIVE];
      const tempText = (tempOp == parent.TEMP_OP.NONE) ? ''
        : (tempOp == parent.TEMP_OP.STATIC) ? `${tempMin}°C<br>`
          : `${tempMin}°C - ${tempMax}°C<br>`;
      const blockText = `${trashCan}${tempText}${hourStart}:${minStart} - ${hourEnd}:${minEnd}`;
      return blockText;
    }

    function changeScheduleOp(origin) {
      if (scheduleSelected in schedules && timerSelected !== undefined) {
        const curSchedule = schedules[scheduleSelected];
        const items = curSchedule.items
        const oldOp = items[timerSelected].operation;
        const newOp = changeDeviceAction(origin, items[timerSelected].operation);
        items[timerSelected].operation = newOp;
        const timerElement = document.getElementById(`si${timerSelected}`);
        timerElement.classList.remove(`schedCol${oldOp}`);
        timerElement.classList.add(`schedCol${newOp}`);
        displaySaveHint();
        refreshThermostat();
      }
    }

    function refreshTimeTable(change) {
      const container = document.getElementById("scheduleContainer");
      const currentSchedule = schedules[scheduleSelected];
      const numTimers = (scheduleSelected in schedules) ? currentSchedule.items.length : 0;
      let newContent = '<div style="position:relative;">';
      newContent += `<div style="height:${pixelsPerMinute*30}px"></div>`;
      let yPos = pixelsPerMinute*30;
      for (let i = 0; i < numTimers; i++) {
        if (i > 0) {
          newContent += `<div id="s${i-1}" class="scheduleSpacer" onpointerdown="dragStart(event, this)" style="top:${yPos-10}px"></div>`;
        }
        const blockText = getTimeBlockText(i);
        const cc = +currentSchedule.items[i].operation;
        const thisHeight = timerHeight(i);
        yPos += thisHeight;
        newContent += `<div id="si${i}" class="scheduleItem schedCol${cc} ${timerSelected===i ? ' scheduleSelect' : ''}" onclick="selectTimer(${i})" style="height:${thisHeight}px">${blockText}</div>`;
      }
      newContent += "</div>";
      container.innerHTML = newContent;
      try {
        refreshThermostat();
      } catch (err) {
        // Don't refresh thermostat when it's not visible
      }
    }

    function selectTimer(sourceId) {
      const sourceElement = document.getElementById(`si${sourceId}`);
      const onoffElement = document.getElementById('timerOpOnOff');
      //const tempElement = document.getElementById('timerBaseTempHeat');
      const ACModeElement = document.getElementById('timerACMode');
      const timeElements = document.getElementById('scTime');
      const ppElements = document.getElementById('scPP');
      //const ppDirtElement = document.getElementById('tempDirtCheap');
      //const ppCheapElement = document.getElementById('tempCheap');
      //const ppExpensiveElement = document.getElementById('tempExpensive');
      //const ppExtremeElement = document.getElementById('tempExtreme');
      const tempOpElement = document.getElementById('timerOpTemp');
      if (timerSelected !== undefined) {
        const oldElement = document.getElementById(`si${timerSelected}`);
        oldElement.classList.remove('scheduleSelect');
      }
      timeElements.disabled = true;
      onoffElement.classList.add('imgButtonDisabled');
      onoffElement.innerHTML = 'N/A';
      ppElements.disabled = true;
      //ppDirtElement.value = '';
      //ppCheapElement.value = '';
      //ppExpensiveElement.value = '';
      //ppExtremeElement.value = '';

      let newOnOffOp = '';
      let newTemp = '';
      let ACMode = 0;
      if (timerSelected === sourceId) {
        timerSelected = undefined;
        tempOpElement.value = TEMPOP.NONE;
      } else {
        timerSelected = sourceId;
        sourceElement.classList.add('scheduleSelect');
        timeElements.disabled = false;
        onoffElement.classList.remove('imgButtonDisabled');
        const currentSchedule = schedules[scheduleSelected];
        newOnOffOp = currentSchedule.items[timerSelected].operation;
        //newTemp = currentSchedule.items[timerSelected].temp;
        ACMode = currentSchedule.items[timerSelected].ACMode;
        ppElements.disabled = false;
        temps = currentSchedule.items[timerSelected].temp;
        //ppDirtElement.value = currentSchedule.items[timerSelected].deltas[0];
        //ppCheapElement.value = currentSchedule.items[timerSelected].deltas[1];
        //ppExpensiveElement.value = currentSchedule.items[timerSelected].deltas[3];
        //ppExtremeElement.value = currentSchedule.items[timerSelected].deltas[4];
        tempOpElement.value = currentSchedule.items[timerSelected].tempOp;
      }
      changeDeviceAction(onoffElement, newOnOffOp, parent.KEEP);
      refreshTempOp();
      refreshThermostat();
      //tempElement.value = newTemp;
      ACModeElement.value = ACMode;
      changeACMode(ACMode);
    }

    function dragStart(e, source) {
      dragging = true;
      aboveItem = source.previousElementSibling;
      belowItem = source.nextElementSibling;
      aboveIdx = +source.id.slice(1);
      belowIdx = aboveIdx + 1;
      prevPosY = event.clientY;
    }

    function moving(e) {
      if (dragging) {
        const items = schedules[scheduleSelected].items;
        let deltaY = e.clientY - prevPosY;
        let deltaMinutes = Math.round(deltaY / (pixelsPerMinute * minuteSnap)) * minuteSnap;
        if (Math.abs(deltaMinutes) >= minuteSnap) {
          const minSize = 60;
          const minAbove = items[belowIdx].start - items[aboveIdx].start;
          const minBelow = (((belowIdx+1)>=items.length) ? (24*60) :items[belowIdx+1].start) - items[belowIdx].start;
          if (minBelow - deltaMinutes < minSize) deltaMinutes = minBelow - minSize;
          if (minAbove + deltaMinutes < minSize) deltaMinutes = minSize - minAbove;
          items[belowIdx].start += deltaMinutes;

          aboveItem.style.height = `${timerHeight(aboveIdx)}px`;
          belowItem.style.height = `${timerHeight(belowIdx)}px`;
          const prevY = +document.getElementById(`s${aboveIdx}`).style.top.slice(0,-2);
          document.getElementById(`s${aboveIdx}`).style.top = `${prevY + deltaMinutes * pixelsPerMinute}px`;

          prevPosY = (deltaMinutes * pixelsPerMinute) + prevPosY;
        }
        document.getElementById(`si${aboveIdx}`).innerHTML = getTimeBlockText(aboveIdx);
        document.getElementById(`si${belowIdx}`).innerHTML = getTimeBlockText(belowIdx);
      }
    }

    function dragStop(e) {
      dragging = false;
      displaySaveHint();
    }

    function changeDeviceAction(button, oldstate, newstate = undefined) {
      if (oldstate !== undefined) {
        if (newstate == undefined) {
          newstate = (oldstate + 1) % 5;
        } else if (newstate == parent.KEEP) {
          newstate = oldstate;
        }
      }
      switch (newstate) {
        case parent.DEVICE_OP.UNCONDITIONAL_OFF:
          button.innerHTML = parent.turnOffText;
          button.style.backgroundImage = 'radial-gradient(white, lightgray, gray)';
          break;
        case parent.DEVICE_OP.UNCONDITIONAL_ON:
          button.innerHTML = parent.turnOnText;
          button.style.backgroundImage = 'radial-gradient(white, rgb(255, 255, 150), orange)';
          break;
        case parent.DEVICE_OP.CONTROLLED_ON:
          button.innerHTML = parent.preferredOnText;
          button.style.backgroundImage = 'radial-gradient(white, rgb(150, 255, 150), green)';
          break;
        case parent.DEVICE_OP.CONTROLLED_OFF:
          button.innerHTML = parent.emergencyOffText;
          button.style.backgroundImage = 'radial-gradient(white, rgb(150, 255, 150), green)';
          break;
        case parent.DEVICE_OP.IGNORE:
          button.innerHTML = parent.ignoreText;
          button.style.backgroundImage = 'radial-gradient(white, lightgray, gray)';
          break;
      }
      return newstate;
    }

    function displaySaveHint() {
        parent.displaySaveHint();
    }

    // ===== THERMOSTAT CODE =====
    var thermoIsDragging = false;
    var thermoDragIndex;
    // Dimensions
    let cWidth = 1;
    let cHeight = 1;
    let tCenterX = 0;
    let tCenterY = 0;
    let outerDia = 1;
    let innerDia = 0;
    // Positions
    const markerStartPos = Math.PI * 8 / 10;
    const markerEndPos = Math.PI * 22 / 10;
    // Temp ranges
    let showHeat = true;
    let showCool = true;
    function pressToAngleCoords(canvas, event) {
      let rect = canvas.getBoundingClientRect();
      let pos = {x: event.clientX - rect.left, y: event.clientY - rect.top };
      let w = pos.x - tCenterX;
      let h = pos.y - tCenterY;
      let pressRadius = Math.sqrt(w * w + h * h);
      let pressAngle = Math.atan2(h, w);
      if (pressAngle < 0) pressAngle += 2*Math.PI;
      if (pressAngle < Math.PI/2) pressAngle += 2*Math.PI;
      let pressTemp = tempToAngle(startTemp, endTemp, markerStartPos, markerEndPos, pressAngle);
      return { pressRadius, pressAngle, pressTemp };
    }

    function startDragThermo(canvas, event) {
      const { pressRadius, pressAngle, pressTemp } = pressToAngleCoords(canvas, event);
      if (pressRadius > innerDia * 0.8 && pressRadius < outerDia * 1.2) {
        let closestIndex;
        let closestDist = Infinity;
        for (let t = 0; t < temps.length; t++) {
          let closeness = Math.abs(pressTemp - temps[t]);
          if ((closeness < closestDist)
            || (closeness === closestDist && (pressTemp > temps[t]))) {
            closestDist = closeness;
            closestIndex = t;
          }
        }
        // minTemp
        if (pressAngle > markerStartPos - Math.PI/10 && pressAngle < markerStartPos + Math.PI/40) {
          console.log('Change min temp')
        }
        // maxTemp
        if (pressAngle > markerEndPos - Math.PI/40 && pressAngle < markerEndPos + Math.PI/10) {
          console.log('Change max temp')
        }
        // Drag Temp
        thermoIsDragging = true;
        thermoDragIndex = closestIndex;
        const timerOpTemp = +document.getElementById('timerOpTemp').value;
        if (timerOpTemp === TEMPOP.STATIC) {
          if (thermoDragIndex >= tempsID.HEAT_EXPENSIVE && thermoDragIndex <= tempsID.HEAT_DIRTCHEAP) thermoDragIndex = tempsID.HEAT_NORMAL;
          if (thermoDragIndex <= tempsID.COOL_EXPENSIVE && thermoDragIndex >= tempsID.COOL_DIRTCHEAP) thermoDragIndex = tempsID.COOL_NORMAL;
        }
        draggingThermo(canvas, event);
        return;
      }
    }

    function setThermoValue(index, newTemp) {
      schedules[scheduleSelected].items[timerSelected].temp[index] = Math.round(newTemp*2)/2;
      temps[index] = newTemp;

      refreshTimeTable();
    }

    function moveThermoIndex(index, newTemp) {
      // Scale Pricepoints if applicable
      const timerOpTemp = +document.getElementById('timerOpTemp').value;
      if (timerOpTemp === TEMPOP.PRICE) {
        if (index === tempsID.HEAT_DIRTCHEAP
          || index === tempsID.HEAT_EXPENSIVE
          || index === tempsID.COOL_DIRTCHEAP
          || index === tempsID.COOL_EXPENSIVE) {
          const oldStart = temps[(index < tempsID.COOL_DIRTCHEAP) ? tempsID.HEAT_EXPENSIVE : tempsID.COOL_DIRTCHEAP];
          const oldEnd = temps[(index < tempsID.COOL_DIRTCHEAP) ? tempsID.HEAT_DIRTCHEAP : tempsID.COOL_EXPENSIVE];
          const newStart = (index === tempsID.HEAT_EXPENSIVE || index === tempsID.COOL_DIRTCHEAP) ? newTemp : oldStart;
          const newEnd = (index === tempsID.HEAT_DIRTCHEAP || index === tempsID.COOL_EXPENSIVE) ? newTemp : oldEnd;
          const iStart = (index < tempsID.COOL_DIRTCHEAP) ? tempsID.HEAT_HIGH : tempsID.COOL_CHEAP;
          const iEnd = (index < tempsID.COOL_DIRTCHEAP) ? tempsID.HEAT_DIRTCHEAP : tempsID.COOL_EXPENSIVE;
          for (let i = iStart; i < iEnd; i++) {
            setThermoValue(i, newStart + ((oldEnd === oldStart)
              ? ((i-iStart+1) / 4 * (newEnd-newStart))
                : (((temps[i]-oldStart)/(oldEnd-oldStart)) * (newEnd-newStart)))
            );
          }
        }
      }
      // Set new temperature
      setThermoValue(index, newTemp);
    }

    function draggingThermo(canvas, event) {
      if (thermoIsDragging) {
        const { pressTemp } = pressToAngleCoords(canvas, event);
        let newTemp = Math.round(pressTemp*2) / 2;
        if (newTemp < startTemp) newTemp = startTemp;
        if (newTemp > endTemp) newTemp = endTemp;
        const timerOpTemp = +document.getElementById('timerOpTemp').value;
        moveThermoIndex(thermoDragIndex, newTemp);
        // Fix up the rest of the values:
        if (timerOpTemp === TEMPOP.STATIC) {
          for (let i = tempsID.HEAT_EXPENSIVE; i <= tempsID.HEAT_DIRTCHEAP; i++) {
            setThermoValue(i, temps[tempsID.HEAT_NORMAL]);
          }
          for (let i = tempsID.COOL_DIRTCHEAP; i <= tempsID.COOL_EXPENSIVE; i++) {
            setThermoValue(i, temps[tempsID.COOL_NORMAL]);
          }
        }
        // Push other values out of the new range
        for (let i = thermoDragIndex - 1; i >= 0; i--) {
          if (temps[i] > newTemp) moveThermoIndex(i, newTemp);
        }
        for (let i = thermoDragIndex + 1; i < temps.length; i++) {
          if (temps[i] < newTemp) moveThermoIndex(i, newTemp);
        }
        refreshThermostat();
      }
    }

    function stopDragThermo(canvas, event) {
      if (thermoIsDragging) {
        draggingThermo(canvas, event);
        thermoIsDragging = false;
      }
    }

    function centerText(ctx, text, x, y, fill = false) {
      const textWidth = ctx.measureText(text).width;
      if (fill) {
        ctx.fillText(text, x - (textWidth/2), y);
      } else {
        ctx.strokeText(text, x - (textWidth/2), y);
      }
    }

    function arcText(ctx, text, x, y, distance, angle) {
      const textWidth = ctx.measureText(text).width;
      const arcX = x + Math.cos(angle) * distance;
      const arcY = y + Math.sin(angle) * distance;
      ctx.fillText(text, arcX - (textWidth/2), arcY);
    }

    function tempToAngle(startAngle, endAngle, startTemp, endTemp, temp) {
      return startAngle + ((endAngle - startAngle) * (temp - startTemp) / (endTemp - startTemp));
    }

    function drawArc(ctx, col, arcStart, arcEnd, radius, width) {
      ctx.beginPath();
      ctx.lineWidth = width;
      const angleStart = tempToAngle(markerStartPos, markerEndPos, startTemp, endTemp, arcStart - 0.25);
      const angleEnd = tempToAngle(markerStartPos, markerEndPos, startTemp, endTemp, arcEnd + 0.25);
      if (Array.isArray(col)) {
        let gr = ctx.createConicGradient(angleStart+(Math.PI/2),tCenterX, tCenterY); 
        let colStop = ((angleEnd-angleStart)/(Math.PI*2))%1;
        if (colStop < 0) return;
        gr.addColorStop(0,col[0]);
        gr.addColorStop(colStop,col[1]); 
        ctx.strokeStyle = gr;
      } else {
        ctx.strokeStyle = col;
      }
      ctx.arc(tCenterX, tCenterY, radius, angleStart, angleEnd);
      ctx.stroke();
    }

    function refreshThermostat(ttt = undefined) {
      if (timerSelected === undefined) return;
      try {
      const canvas = document.getElementById("myThermostat");
      const ctx = canvas.getContext("2d");
      // OnOff temp?
      const curSchedule = schedules[scheduleSelected];
      const items = curSchedule.items;
      const onOffOp = items[timerSelected].operation;
      const tempOp = +document.getElementById('timerOpTemp').value;
      const ACMode = +document.getElementById('timerACMode').value;
      let showTempOnOff =
        (tempOp === TEMPOP.NONE
        || ACMode === parent.ACMODE.AUTO
        || ACMode === parent.ACMODE.DRY
        || ACMode === parent.ACMODE.FAN)
        ? false : true;
      let mustUseTemp =
        onOffOp === parent.DEVICE_OP.IGNORE
        || onOffOp === parent.DEVICE_OP.UNCONDITIONAL_ON // (None for on/off)
        //onOffOp === parent.DEVICE_OP.CONTROLLED_ON    => Temp (onoff else)

      console.log(`Showtemp: ${onOffOp}  ${tempOp}  ${ACMode}`);
      // Dimensions
      cWidth = canvas.width;
      cHeight = canvas.height;
      tCenterX = cWidth / 2;
      tCenterY = cHeight / 2;
      outerDia = Math.min(tCenterX, tCenterY)-10;
      innerDia = outerDia * 3 / 4;
      // Outer circle
      ctx.beginPath();
      ctx.lineWidth = 1;
      ctx.arc(tCenterX, tCenterY, outerDia, 0, 2 * Math.PI);
      ctx.fillStyle = "#DDD";
      ctx.strokeStyle = "#000";
      ctx.fill();
      ctx.stroke();
      // Inner circle
      ctx.beginPath();
      ctx.arc(tCenterX, tCenterY, innerDia, 0, 2 * Math.PI);
      ctx.fillStyle = "#CCC";
      ctx.fill();
      ctx.stroke();
      // Markers
      ctx.lineWidth = 20;
      const numMarkers = 20;
      for (let i = 0; i <= numMarkers; i++) {
        const markerPos = markerStartPos + i * (markerEndPos - markerStartPos) / numMarkers;
        ctx.beginPath();
        ctx.arc(tCenterX, tCenterY, (outerDia + innerDia) / 2, markerPos, markerPos + 0.01);
        ctx.stroke();
      }
      // Show temp ranges
      const timerOpTemp = +document.getElementById('timerOpTemp').value;
      ctx.beginPath();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#000";
      ctx.font = "8px Verdana";
      ctx.fillStyle = "#000";
      arcText(ctx, `${startTemp}°C`, tCenterX, tCenterY, (outerDia+innerDia+4)/2, markerStartPos-(Math.PI/20));
      arcText(ctx, `${endTemp}°C`, tCenterX, tCenterY, (outerDia+innerDia+4)/2, markerEndPos+(Math.PI/20));
      ctx.fill();

      if (showHeat) {
        // Mode specific
        let rangeStart, rangeEnd;
        if (timerOpTemp === TEMPOP.PRICE) {
          rangeStart = temps[tempsID.HEAT_EXPENSIVE];
          rangeEnd = temps[tempsID.HEAT_DIRTCHEAP];
        } else {
          rangeStart = temps[tempsID.HEAT_NORMAL];
          rangeEnd = temps[tempsID.HEAT_NORMAL];
        }
        const text = (rangeStart === rangeEnd) ? `${Math.round(rangeStart*2)/2}` : `>[${Math.round(rangeStart*2)/2},${Math.round(rangeEnd*2)/2}]`;
        // Heat Arc
        drawArc(ctx, "#F00", rangeStart, rangeEnd, outerDia - 4, 8);
        // Heat price points
        if (timerOpTemp === TEMPOP.PRICE) {
          for (let i = tempsID.HEAT_EXPENSIVE; i <= tempsID.HEAT_DIRTCHEAP; i++) {
            drawArc(ctx, "#000", temps[i], temps[i], innerDia + 10, 4);
          }
          drawArc(ctx, ["#0A0", "#0F0"], temps[tempsID.HEAT_CHEAP], temps[tempsID.HEAT_DIRTCHEAP], innerDia + 4, 8);
          drawArc(ctx, ["#00F", "#0A0"], temps[tempsID.HEAT_NORMAL], temps[tempsID.HEAT_CHEAP], innerDia + 4, 8);
          drawArc(ctx, ["#A00", "#00F"], temps[tempsID.HEAT_HIGH], temps[tempsID.HEAT_NORMAL], innerDia + 4, 8);
          drawArc(ctx, ["#F00", "#A00"], temps[tempsID.HEAT_EXPENSIVE], temps[tempsID.HEAT_HIGH], innerDia + 4, 8);
        }
        // Heat Stop
        if (showTempOnOff) {
          drawArc(ctx, "#800", temps[tempsID.HEAT_OFF], temps[tempsID.HEAT_OFF], outerDia - 10, 20);
        }
        // Middle Text
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#D00";
        ctx.font = "14px Verdana";
        ctx.fillStyle = "#000";
        centerText(ctx, "Heating", tCenterX, tCenterY - 30);
        centerText(ctx, `${text}°C`, tCenterX, tCenterY - 10);
        ctx.fill();
      }
      if (showCool) {
        // Mode specific
        let rangeStart, rangeEnd;
        if (timerOpTemp === TEMPOP.PRICE) {
          rangeStart = temps[tempsID.COOL_DIRTCHEAP];
          rangeEnd = temps[tempsID.COOL_EXPENSIVE];
        } else {
          rangeStart = temps[tempsID.COOL_NORMAL];
          rangeEnd = temps[tempsID.COOL_NORMAL];
        }
        const text = (rangeStart === rangeEnd) ? `${Math.round(rangeStart*2)/2}` : `<[${Math.round(rangeStart*2)/2},${Math.round(rangeEnd*2)/2}]`
        // Cool Arc
        drawArc(ctx, "#00F", rangeStart, rangeEnd, outerDia - 4, 8);
        // Cool price points
        if (timerOpTemp === TEMPOP.PRICE) {
          for (let i = tempsID.COOL_DIRTCHEAP; i <= tempsID.COOL_EXPENSIVE; i++) {
            drawArc(ctx, "#000", temps[i], temps[i], innerDia + 10, 4);
          }
          drawArc(ctx, ["#0F0", "#0A0"], temps[tempsID.COOL_DIRTCHEAP], temps[tempsID.COOL_CHEAP], innerDia + 4, 8);
          drawArc(ctx, ["#0A0", "#00F"], temps[tempsID.COOL_CHEAP], temps[tempsID.COOL_NORMAL], innerDia + 4, 8);
          drawArc(ctx, ["#00F", "#A00"], temps[tempsID.COOL_NORMAL], temps[tempsID.COOL_HIGH], innerDia + 4, 8);
          drawArc(ctx, ["#A00", "#F00"], temps[tempsID.COOL_HIGH], temps[tempsID.COOL_EXPENSIVE], innerDia + 4, 8);
        }
        // Cool Stop
        if (showTempOnOff) {
          drawArc(ctx, "#008", temps[tempsID.COOL_OFF], temps[tempsID.COOL_OFF], outerDia - 10, 20);
        }
        // Middle Text
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#00D";
        ctx.font = "14px Verdana";
        ctx.fillStyle = "#000";
        centerText(ctx, "Cooling", tCenterX, tCenterY + 30);
        centerText(ctx, `${text}°C`, tCenterX, tCenterY + 10);
        ctx.fill();
      }
      // Show selected temp:
      const guideText = Number.isFinite(thermoDragIndex) ? `${tempName[thermoDragIndex]}: ${temps[thermoDragIndex]}°C` : '';
      document.getElementById('thermoGuide').innerHTML = guideText;
      } catch (err) {
        console.log(`Err: ${err}`);
      }
    }
    refreshSchedules();
    refreshThermostat();
    </script>
  </body>
</html>
